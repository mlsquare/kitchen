```{r}
install.packages("hash")
```
```{r}
library(hash)
```



```{r Import adult income dataset}
adult_dataset <- read.csv("../../data/raw/adult.data.csv", header = FALSE)
col_names <- c('age', 'workclass', 'fnlwgt', 'education', 'education-num',
         'marital-status', 'occupation', 'relationship', 'race', 'sex', 'capital-gain', 'capital-loss',
         'hours-per-week', 'native-country', 'target')
colnames(adult_dataset) <- col_names

adult_dataset = adult_dataset[adult_dataset["workclass"] != " ?",]
adult_dataset = adult_dataset[adult_dataset["occupation"] != " ?",]
adult_dataset = adult_dataset[adult_dataset$`native-country` != " ?",]
```

```{r Global tree}
set.seed(123)
# tree <- rpart(Species ~ ., data = iris, control = rpart.control(cp = 0.0001))
tree <- rpart(target ~ ., data = adult_dataset[1:10000,], minsplit=1,cp=0)

printcp(tree)
```



```{r Prepare cat variable bins}
cat_var = c("workclass", "education", "marital-status", 'occupation', 'relationship', 'race', 'sex', 'native-country')
max_cat <- max(tree$splits[names(tree$splits[,4]) %in% cat_var,2])
categories <- c(1:max_cat)
set1 <- tbl_df(data.frame(t(combn(categories, 1)), stringsAsFactors = FALSE))
names(set1) <- "new_col"
# set2 <- unite(data.frame(t(combn(categories, 2))), "new_col", sep = "")
# set3 <- unite(data.frame(t(combn(categories, 3))), "new_col", sep = "")

# cat_bind <- rbind(set1, set2)
cat_bind <- set1


itx <- iter(cat_bind[[1]], by = "row")

cat_bind <- foreach(i = itx, j=icount(), .combine = "c") %do% {
  val <- paste("(", cat_bind[[1]][j], ")",sep = "")
  val
}

cat_bind <- data.frame(cat_bind, stringsAsFactors = FALSE)
names(cat_bind) <- "new_col"
cat_bind
```

```{r generate bin_list}
cat_var = c("workclass", "education", "marital-status", 'occupation', 'relationship', 'race', 'sex', 'native-country')
bin_boundaries <- tree$splits[!names(tree$splits[,4]) %in% cat_var,4]
cat_bin_boundaries <- tree$splits[names(tree$splits[,4]) %in% cat_var,4]
# bin_boundaries <- tree$splits[,4]
bin_df <- data.frame(sort(unique(bin_boundaries)))
names(bin_df) <- "new_col"
bin_df <- rbind(bin_df, cat_bind)
# bin_df <- rbind(bin_df, cat_bind) # for cat_var

set1 <- data.frame(LETTERS, stringsAsFactors=FALSE)
names(set1) <- "new_col"
set2 <- unite(data.frame(t(combn(LETTERS,2))), "new_col", sep = "")
set3 <- unite(data.frame(t(combn(LETTERS,3))), "new_col", sep = "")
bin_labels <- bind_rows(set1, set2, set3)

bin_df = transform(bin_df, new_col = as.character(new_col))

bin_list <- list()

itx <- iter(bin_df[[1]], by = "row")
bin_list <- foreach(i = itx, j=icount(), .combine = "c") %do% {
  if ("(" == strsplit(bin_df[[1]][j], split="")[[1]][1]){
    val <- bin_labels[[1]][j]
    }
  else{
    val <- list(list(bin_labels[[1]][j]))
    }
  names(val) <- as.character(i)
  val
}

label_list <- list()

itx <- iter(bin_df[[1]], by = "row")

label_list <- foreach(i = itx, j=icount(), .combine = "c") %do% {
  val <- i
  names(val) <- bin_labels[[1]][j]
  val
}
```


```{r Check for duplicate bins}
get_updated_binlist <- function(new_boundaries, bin_list){
  new_boundaries <- new_boundaries[!(new_boundaries[[1]] %in% names(bin_list)),]
  if (length(new_boundaries)>0){
    for (i in 1: length(new_boundaries)){
    index <- length(bin_list) + 1
    val <- list(list(bin_labels[[1]][index]))
    names(val) <- as.character(new_boundaries[i])
    bin_list <- c(bin_list, val)
    }
  }
  return(bin_list)
}
# use dict instead of this loop
```

```{r return_path function}
## Traversing tree using an instance from input data(x)
return_path <- function(x){
  node <- 1
  nspl <- 1
  path_list <- list()
  test_yval <- list()
  # temp_path <- list()
  while(nspl != 0){
    # i <- x
    # i <- subset(x, select=-c(survived))
    i <- subset(x, select=-c(target))
    npos <- match(node, nnum)
    nspl <- nodes[4][npos,] # Recheck
    var <- vnum[nspl]
    ncat <- split_df[2][nspl,]
    temp <- split_df[4][nspl,]
      if (nspl > 0){
        if (ncat >= 2){
          dir = csplit[temp,as.integer(i[var])]
          # levels <- bin_labels[[1]][length(bin_list)+1]
          # names(levels) <- as.integer(x[var])
          # path_list <- c(path_list, bin_list[[1]][-1])
          label <- ifelse(dir == -1, 0, 1)
          level <- paste("(", as.character(i[var]), ")", sep = "")
          if (!(level %in% keys(invert(global_bins)))){
                .set(global_bins, keys=bin_labels$new_col[length(global_bins)+1], values=level)
          }
          ## old flow
          # node_decision <- paste(as.character(var), bin_list[[level]], label, sep = "")
          
          node_decision <- paste(as.character(var), invert(global_bins)[[level]], label, sep = "")
          # path_list <- c(path_list, var,bin_list[[level]])
          path_list <- c(path_list, node_decision)
          # print(level)
          # print(dir)
        }
        else if (i[var] < temp){
          # print(temp)
          # label <- ifelse(ncat==-1, bin_list[[as.character(temp)]][1], bin_list[[as.character(temp)]][2]) # Validate results!
          # label <- bin_list[[as.character(temp)]][1]
          if (!(as.character(temp) %in% keys(invert(global_bins)))){
                .set(global_bins, keys=bin_labels$new_col[length(global_bins)+1], values=as.character(temp))
          }
          label <- invert(global_bins)[[as.character(temp)]]
          node_decision <- paste(as.character(var), label, 0, sep = "")
          # print(label)
          # path_list <- c(path_list, var,label)
          path_list <- c(path_list, node_decision)
          dir = ncat
          # print(dir)
        }
        else {
          # label <- ifelse(ncat==1, bin_list[[as.character(temp)]][1], bin_list[[as.character(temp)]][2]) # Validate results!
          # label <- bin_list[[as.character(temp)]][1]
          if (!(as.character(temp) %in% keys(invert(global_bins)))){
                .set(global_bins, keys=bin_labels$new_col[length(global_bins)+1], values=as.character(temp))
          }
          label <- invert(global_bins)[[as.character(temp)]]
          node_decision <- paste(as.character(var), label, 1, sep = "")
          # print(label)
          # path_list <- c(path_list, var,label)
          path_list <- c(path_list, node_decision)
          dir = -ncat
          # print(dir)
        }

        if (dir == -1){
          node = 2 * node
        }
        else{
          node = 2 * node + 1
        }
      }
    else{
      # print("leaf node")
      # test_yval <- c(test_yval, tree$frame$yval[node])
    }
  }
  path_list = paste(path_list, collapse = ",")
  names(path_list) <- "new_col"
  return(path_list)
}
```

```{r Local DT workflow}
# itx <- iter(adult_dataset[,1:14], by = "row")

# final_paths <- data.frame(matrix(ncol = 1, nrow = nrow(adult_dataset)))
final_paths <- data.frame(matrix(ncol = 1, nrow = 1000))

set1 <- data.frame(LETTERS, stringsAsFactors=FALSE)
names(set1) <- "new_col"
set2 <- unite(data.frame(t(combn(LETTERS,2))), "new_col", sep = "")
set3 <- unite(data.frame(t(combn(LETTERS,3))), "new_col", sep = "")
bin_labels <- bind_rows(set1, set2, set3)


# bin_tracker <- 1
# label_tracker <- 1
# bin_list <- list()
# bin_df <- data.frame()

global_bins <- hash()


## changes to fix memory issues
# 1) Move bin creation to a function - bin_df, bin_list. Check for duplicates and return updated list.
# 2) Move bin_labels out of loops


# set1 <- data.frame(LETTERS, stringsAsFactors=FALSE)
# names(set1) <- "new_col"
# set2 <- unite(data.frame(t(combn(LETTERS,2))), "new_col", sep = "")
# set3 <- unite(data.frame(t(combn(LETTERS,3))), "new_col", sep = "")
# bin_labels <- bind_rows(set1, set2, set3)

# pdf("test_plot.pdf") #Outside the loop
# 
# path.to.root <- function(node){
#   if(node == 1)   # root?
#     node
#   else            # recurse, %/% 2 gives the parent of node
#     c(node, path.to.root(node %/% 2))
#   }

# foreach(i = itx, j=icount(), .combine = "c") %dopar% {
for (iter_index in 1:1000) {
    # x <- data.frame(i)
    x <- adult_dataset[iter_index, 1:15]
    x <- x[rep(seq_len(nrow(x)), 250),]
    x <- x[rowSums(is.na(x)) == 0,]
    # remaining_df <- adult_dataset[-c(iter_index),1:15] # exclude current instance!, sample with indices not
    # random_sample <- remaining_df[sample(nrow(adult_dataset)),]
    # x <- rbind(x, random_sample[1:750,])
    
    # x <- rbind(x, adult_dataset[-c(iter_index),1:15][sample(nrow(adult_dataset)),][1:750,])
    
    x <- rbind(x, adult_dataset %>%
                 slice(-c(iter_index))%>%
                 slice(sample(nrow(adult_dataset)))%>%
                 slice(1:750))
    
    ## Feedback from Soma
    # Create one set with all dataset -- index_set = 1 to 1000
    # i = index in focus
    # i_c = index set - i
    # net_index = concat(rep(i,250), sample(i_c, 750))
    
    ## Create local tree and export details as csv
    local_tree <- rpart(target ~ ., data = x, minsplit=1,cp=0)
    frame_csv_name <- paste0("local_dt_info/frame", "_", iter_index,".csv")
    splits_csv_name <- paste0("local_dt_info/splits", "_", iter_index,".csv")
    write.csv(local_tree$frame, file=frame_csv_name)
    write.csv(local_tree$splits, file=splits_csv_name)
    
    # cat_var = c("workclass", "education", "marital-status", 'occupation', 'relationship', 'race', 'sex', 'native-country')
    # bin_boundaries <- local_tree$splits[!names(local_tree$splits[,4]) %in% cat_var,4]
    # cat_bin_boundaries <- local_tree$splits[names(local_tree$splits[,4]) %in% cat_var,4]
    
    ## old workflow
    # bin_df <- data.frame(sort(unique(bin_boundaries)))
    # names(bin_df) <- "new_col"
    # bin_df <- rbind(bin_df, cat_bind)
    
    # local_bins <- sort(unique(bin_boundaries))
    # local_bins <- append(local_bins, cat_bind$new_col) ## Recheck
    # 
    # unique_local_bins <- local_bins[!(local_bins %in% keys(invert(global_bins)))]
    # start_index <- length(global_bins) + 1
    # end_index <- start_index + length(unique_local_bins) - 1
    # .set(global_bins, keys=bin_labels$new_col[start_index:end_index], 
    #      values=unique_local_bins)
    
    # bin_df = transform(bin_df, new_col = as.character(new_col))
    
    # bin_list <- list()
    # 
    # itx <- iter(bin_df[[1]], by = "row")
    # bin_list <- foreach(i = itx, j=icount(), .combine = "c") %do% {
    #   if ("(" == strsplit(bin_df[[1]][j], split="")[[1]][1]){
    #     val <- bin_labels[[1]][j]
    #     }
    #   else{
    #     val <- list(list(bin_labels[[1]][j]))
    #     }
    #   names(val) <- as.character(i)
    #   val
    # }
    
    # label_list <- list()
    # 
    # itx <- iter(bin_df[[1]], by = "row")
    # 
    # label_list <- foreach(i = itx, j=icount(), .combine = "c") %do% {
    #   val <- i
    #   names(val) <- bin_labels[[1]][j]
    #   val
    # }
    
    # names(bin_df) <- "new_col"
    
    # bin_list <- get_updated_binlist(bin_df, bin_list)
    
    temp_frame <- local_tree$frame

    nc <- temp_frame[, c("ncompete", "nsurrogate")]

    temp_frame$index <- 1L + c(0L, cumsum((temp_frame$var != "<leaf>") + nc[[1L]] + nc[[2L]]))[-(nrow(temp_frame) + 1L)] ## Validate the values!

    temp_frame$index[temp_frame$var == "<leaf>"] <- 0L

    nodes <- temp_frame[, c("n", "ncompete", "nsurrogate", "index")]

    nnum = row.names(temp_frame)

    # vnum <- match(rownames(tree$splits), colnames(x))
    vnum <- match(rownames(local_tree$splits), colnames(adult_dataset[1,]))

    split <- local_tree$splits

    split_rownames <- rownames(split)

    split_df <- as.data.frame(split, row.names = 0)

    csplit <- local_tree$csplit -2L

    path_list <- return_path(adult_dataset[iter_index,1:15])
    # print(path_list)
    # print(j)
    final_paths[iter_index, ] <- path_list
    # cutpoints[j, ] <- path_list
}
```

```{r Export paths and labels}
write.csv(final_paths, file="local_adult_paths_1000.csv")
label_df <- data.frame(values(global_bins))
write.csv(label_list, file="local_adult_bin_labels_1000.csv")
```

```{r hash package trials}

global_bins <- hash(keys=c("A", "B", "C"), values = c(3.5, 2.5, 1.8))

# local_bins <- hash(keys=c("A", "B", "C", ), values = c(3.5, 1.8, 1.2, 2.2, 3.6))
local_bins <- list(3.5, 1.8, 1.2, 2.2, "(42)")

# new_cutpoints <- keys(invert(local_bins))[!(keys(invert(local_bins)) %in% keys(invert(global_bins)))]


.set(global_bins, keys=bin_labels$new_col[4:6], values=local_bins[!(local_bins %in% keys(invert(global_bins)))])

```


